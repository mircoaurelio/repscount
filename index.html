<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
    <title>Reps Count</title>
    <style>
      :root {
        --bg: #050712;
        --panel: rgba(14, 18, 32, 0.46);
        --panel2: rgba(14, 18, 32, 0.28);
        --text: rgba(255, 255, 255, 0.92);
        --muted: rgba(255, 255, 255, 0.68);
        --danger: #ff4d4d;
        --accent: #6ee7ff;
        --ok: #35d07f;
        --shadow: 0 16px 50px rgba(0, 0, 0, 0.55);
        --shadow2: 0 2px 0 rgba(255, 255, 255, 0.06) inset, 0 -1px 0 rgba(0, 0, 0, 0.25) inset;
        --border: rgba(255, 255, 255, 0.18);
        --border2: rgba(255, 255, 255, 0.28);
        --blur: 18px;
        --radius: 16px;
      }

      * { box-sizing: border-box; }
      html, body { height: 100%; }
      body {
        margin: 0;
        background:
          radial-gradient(1200px circle at 15% 10%, rgba(110, 231, 255, 0.10), transparent 60%),
          radial-gradient(900px circle at 90% 20%, rgba(168, 85, 247, 0.10), transparent 55%),
          radial-gradient(700px circle at 45% 92%, rgba(53, 208, 127, 0.08), transparent 60%),
          linear-gradient(180deg, rgba(4, 6, 14, 1), rgba(5, 7, 18, 1));
        color: var(--text);
        font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji",
          "Segoe UI Emoji";
        overflow: hidden;
      }

      /* Fullscreen camera stage */
      .stage {
        position: fixed;
        inset: 0;
        background: #000;
      }
      .stage::before {
        content: "";
        position: absolute;
        inset: 0;
        pointer-events: none;
        /* subtle neon + vignette so glass reads over video */
        background:
          radial-gradient(1200px circle at 20% 10%, rgba(110, 231, 255, 0.18), transparent 58%),
          radial-gradient(900px circle at 85% 22%, rgba(168, 85, 247, 0.16), transparent 58%),
          radial-gradient(700px circle at 45% 95%, rgba(53, 208, 127, 0.12), transparent 62%),
          linear-gradient(180deg, rgba(0, 0, 0, 0.08), rgba(0, 0, 0, 0.40));
        z-index: 2;
      }
      #video {
        position: absolute;
        inset: 0;
        width: 100%;
        height: 100%;
        object-fit: cover;
        transform: scaleX(-1); /* mirror for user-friendly view */
        visibility: hidden; /* we draw to canvas */
      }
      #output {
        position: absolute;
        inset: 0;
        width: 100%;
        height: 100%;
        z-index: 1;
      }

      /* Overlay UI */
      .hud {
        position: absolute;
        inset: 0;
        pointer-events: none;
        padding: max(14px, env(safe-area-inset-top)) max(14px, env(safe-area-inset-right))
          max(14px, env(safe-area-inset-bottom)) max(14px, env(safe-area-inset-left));
        display: grid;
        grid-template-rows: auto 1fr auto;
        gap: 12px;
        z-index: 3;
      }
      .topbar {
        pointer-events: auto;
        display: grid;
        grid-template-columns: 1fr auto;
        gap: 12px;
        align-items: start;
      }
      .card {
        position: relative;
        overflow: hidden;
        background:
          linear-gradient(135deg, rgba(255, 255, 255, 0.14), rgba(255, 255, 255, 0.04)),
          var(--panel);
        border: 1px solid var(--border);
        border-radius: var(--radius);
        box-shadow: var(--shadow), var(--shadow2);
        backdrop-filter: blur(var(--blur)) saturate(140%);
        -webkit-backdrop-filter: blur(var(--blur)) saturate(140%);
      }
      .card::before {
        content: "";
        position: absolute;
        inset: 0;
        pointer-events: none;
        background:
          radial-gradient(900px circle at 18% 0%, rgba(255, 255, 255, 0.20), transparent 55%),
          radial-gradient(700px circle at 85% 120%, rgba(255, 255, 255, 0.10), transparent 60%);
        opacity: 0.85;
      }
      .card > * { position: relative; }
      .controls {
        padding: 12px;
        display: grid;
        gap: 10px;
        min-width: min(520px, 100%);
      }
      .brand {
        padding: 12px;
        display: grid;
        gap: 6px;
        align-content: start;
      }
      .brand h1 {
        margin: 0;
        font-size: 16px;
        letter-spacing: 0.5px;
        display: flex;
        align-items: center;
        gap: 10px;
      }
      .pill {
        font-size: 12px;
        padding: 4px 10px;
        border-radius: 999px;
        border: 1px solid var(--border);
        background:
          linear-gradient(135deg, rgba(255, 255, 255, 0.12), rgba(255, 255, 255, 0.02)),
          var(--panel2);
        color: var(--muted);
      }
      .brand p {
        margin: 0;
        font-size: 12px;
        color: var(--muted);
        line-height: 1.35;
      }

      .row {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 10px;
      }
      label {
        display: grid;
        gap: 6px;
        font-size: 12px;
        color: var(--muted);
      }
      select, input {
        appearance: none;
        background:
          linear-gradient(135deg, rgba(255, 255, 255, 0.12), rgba(255, 255, 255, 0.02)),
          rgba(0, 0, 0, 0.28);
        border: 1px solid var(--border);
        color: var(--text);
        border-radius: 12px;
        padding: 10px 10px;
        outline: none;
        box-shadow: 0 1px 0 rgba(255, 255, 255, 0.06) inset;
        backdrop-filter: blur(12px) saturate(140%);
        -webkit-backdrop-filter: blur(12px) saturate(140%);
      }
      select:focus-visible, input:focus-visible {
        border-color: rgba(110, 231, 255, 0.55);
        box-shadow:
          0 1px 0 rgba(255, 255, 255, 0.06) inset,
          0 0 0 3px rgba(110, 231, 255, 0.18);
      }
      input[type="number"] { width: 100%; }

      .stats {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 10px;
      }
      .stat {
        padding: 10px 12px;
        display: grid;
        gap: 2px;
      }
      .stat .k {
        font-size: 12px;
        color: var(--muted);
      }
      .stat .v {
        font-size: 24px;
        font-weight: 700;
        letter-spacing: 0.2px;
      }
      .mini {
        font-size: 12px;
        color: var(--muted);
      }

      /* Advanced stats (expandable) */
      details.advancedPanel {
        padding: 10px 12px;
      }
      details.advancedPanel > summary {
        list-style: none;
        cursor: pointer;
        user-select: none;
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 10px;
        outline: none;
      }
      details.advancedPanel > summary::-webkit-details-marker { display: none; }
      details.advancedPanel > summary:focus-visible {
        border-radius: 12px;
        box-shadow: 0 0 0 3px rgba(110, 231, 255, 0.18);
      }
      .advancedTitle {
        display: flex;
        align-items: center;
        gap: 10px;
        font-weight: 650;
      }
      .chev {
        width: 18px;
        height: 18px;
        display: inline-block;
        border-radius: 999px;
        border: 1px solid var(--border);
        background: rgba(0, 0, 0, 0.22);
        position: relative;
        flex: 0 0 auto;
      }
      .chev::before {
        content: "";
        position: absolute;
        inset: 0;
        margin: auto;
        width: 7px;
        height: 7px;
        border-right: 2px solid rgba(255, 255, 255, 0.78);
        border-bottom: 2px solid rgba(255, 255, 255, 0.78);
        transform: translateY(-1px) rotate(45deg);
      }
      details[open].advancedPanel .chev::before { transform: translateY(1px) rotate(225deg); }
      .advancedBody { margin-top: 10px; display: grid; gap: 10px; }
      .advancedGrid {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 10px;
      }
      .advStat {
        border: 1px solid rgba(255, 255, 255, 0.14);
        background:
          linear-gradient(135deg, rgba(255, 255, 255, 0.10), rgba(255, 255, 255, 0.02)),
          rgba(0, 0, 0, 0.18);
        border-radius: 14px;
        padding: 10px 12px;
        display: grid;
        gap: 2px;
      }
      .advStat .k { font-size: 12px; color: var(--muted); }
      .advStat .v { font-size: 18px; font-weight: 700; letter-spacing: 0.2px; }
      .chartWrap {
        border: 1px solid rgba(255, 255, 255, 0.14);
        background: rgba(0, 0, 0, 0.22);
        border-radius: 14px;
        padding: 10px 10px 8px;
      }
      #advChart {
        width: 100%;
        height: 140px;
        display: block;
        border-radius: 12px;
      }
      .chartHint { margin-top: 6px; font-size: 12px; color: var(--muted); }

      .buttons {
        display: grid;
        grid-template-columns: 1fr 1fr 1fr;
        gap: 10px;
      }
      button {
        pointer-events: auto;
        border: 1px solid var(--border);
        background:
          linear-gradient(135deg, rgba(255, 255, 255, 0.12), rgba(255, 255, 255, 0.02)),
          rgba(0, 0, 0, 0.25);
        color: var(--text);
        border-radius: 14px;
        padding: 10px 12px;
        font-weight: 650;
        cursor: pointer;
        backdrop-filter: blur(14px) saturate(140%);
        -webkit-backdrop-filter: blur(14px) saturate(140%);
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.35), 0 1px 0 rgba(255, 255, 255, 0.06) inset;
        transition: transform 0.06s ease, background 0.2s ease, border-color 0.2s ease, box-shadow 0.2s ease;
      }
      button:hover {
        border-color: var(--border2);
        box-shadow: 0 14px 38px rgba(0, 0, 0, 0.42), 0 1px 0 rgba(255, 255, 255, 0.07) inset;
      }
      button:active { transform: translateY(1px); }
      button:focus-visible {
        outline: none;
        border-color: rgba(110, 231, 255, 0.55);
        box-shadow:
          0 14px 38px rgba(0, 0, 0, 0.42),
          0 0 0 3px rgba(110, 231, 255, 0.18);
      }
      button.primary {
        border-color: rgba(110, 231, 255, 0.35);
        background:
          linear-gradient(135deg, rgba(110, 231, 255, 0.26), rgba(110, 231, 255, 0.08)),
          rgba(0, 0, 0, 0.18);
      }
      button.danger {
        border-color: rgba(255, 77, 77, 0.35);
        background:
          linear-gradient(135deg, rgba(255, 77, 77, 0.22), rgba(255, 77, 77, 0.06)),
          rgba(0, 0, 0, 0.18);
      }
      button.ghost {
        border-color: rgba(255, 255, 255, 0.22);
        background:
          linear-gradient(135deg, rgba(255, 255, 255, 0.10), rgba(255, 255, 255, 0.02)),
          rgba(0, 0, 0, 0.18);
        color: rgba(255, 255, 255, 0.86);
        font-weight: 600;
      }

      .footer {
        pointer-events: auto;
        display: grid;
        grid-template-columns: 1fr;
        justify-items: end;
        align-items: end;
        gap: 10px;
      }

      /* Mobile bottom readout (hidden on desktop) */
      .mobileReadout { display: none; padding: 12px; }
      .mobileReadoutGrid {
        display: grid;
        grid-template-columns: 1.2fr 1fr;
        gap: 12px;
        align-items: end;
      }
      .mobileBlock { display: grid; gap: 4px; }
      .mobileLabel {
        font-size: 12px;
        color: var(--muted);
        letter-spacing: 0.2px;
      }
      .mobileBigReps {
        font-weight: 800;
        letter-spacing: 0.2px;
        line-height: 0.95;
        font-size: clamp(40px, 10vw, 68px);
      }
      .mobileBigTime {
        font-weight: 750;
        letter-spacing: 0.2px;
        line-height: 1;
        font-size: clamp(22px, 6.5vw, 38px);
        text-align: right;
      }
      .mobileSub {
        font-size: 12px;
        color: rgba(255, 255, 255, 0.62);
      }
      .mobileSubRight { text-align: right; }
      .mobileAccent { color: rgba(110, 231, 255, 0.92); }
      .toggles {
        padding: 10px 12px;
        display: flex;
        gap: 12px;
        align-items: center;
        justify-content: flex-end;
      }
      .toggle {
        display: inline-flex;
        gap: 8px;
        align-items: center;
        font-size: 12px;
        color: var(--muted);
        user-select: none;
      }
      .toggle input { width: 16px; height: 16px; }

      .badge {
        display: inline-flex;
        gap: 6px;
        align-items: center;
        font-size: 12px;
        color: var(--muted);
      }
      .dot {
        width: 8px;
        height: 8px;
        border-radius: 999px;
        background: rgba(255, 255, 255, 0.25);
      }
      .dot.ok { background: var(--ok); }
      .dot.bad { background: var(--danger); }

      .centerHint {
        pointer-events: none;
        position: absolute;
        left: 50%;
        top: 50%;
        transform: translate(-50%, -50%);
        text-align: center;
        max-width: min(520px, 92vw);
        padding: 14px 16px;
        display: none;
        z-index: 4;
      }
      .centerHint strong { display: block; margin-bottom: 6px; }
      .centerHint .small { color: var(--muted); font-size: 12px; line-height: 1.35; }

      .span2 { grid-column: 1 / -1; }

      /* Rep feedback: green border flash */
      .repFlash {
        position: fixed;
        inset: 0;
        pointer-events: none;
        z-index: 5;
        opacity: 0;
        box-shadow:
          inset 0 0 0 0 rgba(53, 208, 127, 0),
          inset 0 0 0 0 rgba(53, 208, 127, 0);
        transition: opacity 120ms ease, box-shadow 120ms ease;
      }
      .repFlash.on {
        opacity: 1;
        box-shadow:
          inset 0 0 0 10px rgba(53, 208, 127, 0.85),
          inset 0 0 0 18px rgba(53, 208, 127, 0.18);
      }

      /* Timed pause/prep box */
      .pauseBox {
        pointer-events: none;
        position: absolute;
        left: 50%;
        top: 50%;
        transform: translate(-50%, -50%);
        text-align: center;
        max-width: min(520px, 92vw);
        padding: 16px 18px;
        display: none;
        z-index: 6;
      }
      .pauseBox .title {
        font-size: 12px;
        letter-spacing: 0.5px;
        color: var(--muted);
        margin-bottom: 6px;
        text-transform: uppercase;
      }
      .pauseBox .time {
        font-size: 42px;
        font-weight: 800;
        letter-spacing: 0.5px;
        line-height: 1.05;
        margin-bottom: 6px;
      }
      .pauseBox .sub {
        color: var(--muted);
        font-size: 12px;
        line-height: 1.35;
      }

      @supports not ((backdrop-filter: blur(1px)) or (-webkit-backdrop-filter: blur(1px))) {
        .card {
          background: rgba(15, 18, 30, 0.92);
        }
        button, select, input {
          background: rgba(0, 0, 0, 0.52);
        }
      }

      /* Mobile/short screens: ultra-compact HUD (camera-first).
         Default occupies ~<10% of the screen; "Settings" expands when needed. */
      @media (max-width: 720px), (max-height: 680px) {
        .hud {
          padding: max(8px, env(safe-area-inset-top)) max(8px, env(safe-area-inset-right))
            max(8px, env(safe-area-inset-bottom)) max(8px, env(safe-area-inset-left));
          gap: 8px;
        }

        /* Hide non-essential panels by default */
        .brand { display: none; }
        .footer { display: grid; justify-items: stretch; }
        .toggles { display: none; }
        .mobileReadout { display: block; }

        .topbar { grid-template-columns: 1fr; }

        /* Compact dock: stats strip + buttons */
        .controls {
          min-width: 0;
          padding: 8px;
          gap: 8px;
          display: block;
          max-height: none;
        }

        .row { display: none; }
        .mini { display: none; }

        .stats { display: none; }
        #advancedPanel { display: none; }

        .buttons {
          width: 100%;
          display: grid;
          grid-template-columns: 1fr 1fr;
          gap: 8px;
        }
        button {
          padding: 10px 10px;
          border-radius: 12px;
          font-size: 13px;
          line-height: 1;
          min-height: 44px;
        }

        /* Center hint smaller on mobile */
        .centerHint { max-width: min(420px, 92vw); padding: 10px 12px; }
        .centerHint strong { font-size: 13px; }
        .centerHint .small { font-size: 11px; }

        /* Settings button only needed on mobile */
        #uiToggle { display: inline-flex; }

        /* Expanded mode (tap "Settings") */
        body.uiExpanded .footer { display: grid; grid-template-columns: 1fr; gap: 10px; }
        body.uiExpanded .toggles { display: flex; justify-content: space-between; }
        body.uiExpanded .controls {
          display: grid;
          grid-template-columns: 1fr;
          max-height: 72vh; /* enough room for advanced panel + chart */
          overflow: auto;
          overscroll-behavior: contain;
          -webkit-overflow-scrolling: touch;
        }
        body.uiExpanded .row { display: grid; }
        body.uiExpanded .stats {
          display: grid;
          grid-template-columns: 1fr 1fr;
          overflow: visible;
          padding-bottom: 0;
        }
        body.uiExpanded .stats .stat { display: grid; }
        body.uiExpanded #advancedPanel { display: block; }
        body.uiExpanded .advancedGrid { grid-template-columns: 1fr; }
        body.uiExpanded #advChart { height: 110px; }
        body.uiExpanded .stat .k { display: block; }
        body.uiExpanded .mini { display: block; }
        body.uiExpanded .buttons {
          display: grid;
          grid-template-columns: 1fr 1fr;
          position: sticky;
          bottom: 0;
          padding-top: 10px;
          background: linear-gradient(180deg, rgba(5, 7, 18, 0.0), rgba(5, 7, 18, 0.65) 45%, rgba(5, 7, 18, 0.85));
          backdrop-filter: blur(10px) saturate(130%);
          -webkit-backdrop-filter: blur(10px) saturate(130%);
        }
        body.uiExpanded #uiToggle { grid-column: 1 / -1; }
      }

      /* Very narrow phones: stack the select + timer */
      @media (max-width: 420px) {
        .row { grid-template-columns: 1fr; }
      }
    </style>
  </head>
  <body>
    <div class="stage" aria-label="Camera stage">
      <video id="video" playsinline muted></video>
      <canvas id="output"></canvas>

      <div id="repFlash" class="repFlash" aria-hidden="true"></div>

      <div id="pauseBox" class="card pauseBox" aria-live="polite">
        <div id="pauseBoxTitle" class="title">Pause</div>
        <div id="pauseBoxTime" class="time">00:10</div>
        <div id="pauseBoxSub" class="sub">Get ready…</div>
      </div>

      <div class="hud">
        <div class="topbar">
          <div class="card brand">
            <h1>
              Reps Count
              <span class="badge" title="Pose tracking confidence">
                <span id="trackDot" class="dot"></span>
                <span id="trackText">Waiting…</span>
              </span>
            </h1>
            <p>
              Choose an exercise, hit Start, and perform reps in front of the camera.
              UI stays over the camera feed (full screen).
            </p>
          </div>

          <div class="card controls">
            <div class="row">
              <label>
                Exercise
                <select id="exercise">
                  <option value="squats">Squats</option>
                  <option value="pushups">Push-ups</option>
                  <option value="handstandpushups">Handstand push-ups</option>
                  <option value="pullups">Pull-ups</option>
                </select>
              </label>
              <label>
                Mode
                <select id="mode">
                  <option value="time">Time</option>
                  <option value="reps">Reps</option>
                </select>
              </label>
              <label>
                Timer (seconds, 0 = stopwatch)
                <input id="duration" type="number" min="0" step="5" value="60" />
              </label>
              <label>
                Target reps
                <input id="targetReps" type="number" min="1" step="1" value="10" />
              </label>
              <label>
                Load (kg)
                <input id="loadKg" type="number" min="0" step="1" value="0" />
              </label>
              <label>
                Lift height (cm)
                <input id="liftCm" type="number" min="0" step="1" value="0" />
              </label>
              <label class="span2">
                Pause (seconds)
                <input id="pauseSeconds" type="number" min="0" step="1" value="10" />
              </label>
              <label class="span2">
                Series (sets)
                <input id="series" type="number" min="1" step="1" value="3" />
              </label>
            </div>

            <div class="stats">
              <div class="card stat">
                <div id="timeLabel" class="k">Time</div>
                <div id="time" class="v">01:00</div>
                <div id="status" class="mini">Ready</div>
              </div>
              <div class="card stat">
                <div class="k">Reps</div>
                <div id="reps" class="v">0</div>
                <div id="phase" class="mini">Phase: —</div>
              </div>
              <div class="card stat">
                <div class="k">Power (kW)</div>
                <div id="powerKw" class="v">—</div>
                <div class="mini">Est. from load + height</div>
              </div>
              <div class="card stat">
                <div class="k">Load (kg)</div>
                <div id="loadKgStat" class="v">0</div>
                <div id="liftCmStat" class="mini">Height: 0 cm</div>
              </div>
            </div>

            <details id="advancedPanel" class="card advancedPanel">
              <summary aria-label="Toggle advanced statistics">
                <div class="advancedTitle">
                  <span class="chev" aria-hidden="true"></span>
                  <span>Advanced stats</span>
                </div>
                <div id="advSummary" class="mini">—</div>
              </summary>
              <div class="advancedBody">
                <div class="advancedGrid" aria-label="Advanced statistics">
                  <div class="advStat">
                    <div class="k">Pace</div>
                    <div id="advPace" class="v">—</div>
                  </div>
                  <div class="advStat">
                    <div class="k">Active time</div>
                    <div id="advActive" class="v">—</div>
                  </div>
                  <div class="advStat">
                    <div class="k">Avg rep interval</div>
                    <div id="advAvgInt" class="v">—</div>
                  </div>
                  <div class="advStat">
                    <div class="k">Last interval</div>
                    <div id="advLastInt" class="v">—</div>
                  </div>
                  <div class="advStat">
                    <div class="k">Best / worst interval</div>
                    <div id="advBestWorst" class="v">—</div>
                  </div>
                  <div class="advStat">
                    <div class="k">Consistency (σ)</div>
                    <div id="advStd" class="v">—</div>
                  </div>
                </div>
                <div class="chartWrap">
                  <canvas id="advChart" aria-label="Reps over time graph"></canvas>
                  <div class="chartHint">Graph: cumulative reps over time (current set).</div>
                </div>
              </div>
            </details>

            <div class="buttons">
              <button id="start" class="primary" type="button">Start</button>
              <button id="pause" type="button">Pause</button>
              <button id="reset" class="danger" type="button">Reset</button>
              <button id="uiToggle" class="ghost" type="button" aria-expanded="false">Settings</button>
            </div>
          </div>
        </div>

        <div></div>

        <div class="footer">
          <div class="card mobileReadout" aria-label="Live workout readout">
            <div class="mobileReadoutGrid">
              <div class="mobileBlock">
                <div class="mobileLabel">Reps</div>
                <div id="mobileReps" class="mobileBigReps mobileAccent">0</div>
                <div id="mobilePhase" class="mobileSub">Phase: —</div>
              </div>
              <div class="mobileBlock">
                <div id="mobileTimeLabel" class="mobileLabel" style="text-align:right">Time</div>
                <div id="mobileTime" class="mobileBigTime">01:00</div>
                <div id="mobileStatus" class="mobileSub mobileSubRight">Ready</div>
              </div>
            </div>
          </div>
          <div class="card toggles">
            <label class="toggle">
              <input id="draw" type="checkbox" checked />
              Draw skeleton
            </label>
            <label class="toggle">
              <input id="sound" type="checkbox" checked />
              Sound
            </label>
            <label class="toggle">
              <input id="mirror" type="checkbox" checked />
              Mirror
            </label>
          </div>
        </div>
      </div>

      <div id="centerHint" class="card centerHint">
        <strong id="centerHintTitle">Camera permission needed</strong>
        <div id="centerHintBody" class="small"></div>
      </div>
    </div>

    <!-- MediaPipe (UMD) -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose/pose.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>

    <script>
      (function () {
        /** @type {HTMLVideoElement} */
        const videoEl = document.getElementById("video");
        /** @type {HTMLCanvasElement} */
        const canvasEl = document.getElementById("output");
        const ctx = canvasEl.getContext("2d", { alpha: false });

        const exerciseEl = document.getElementById("exercise");
        const modeEl = document.getElementById("mode");
        const durationEl = document.getElementById("duration");
        const targetRepsEl = document.getElementById("targetReps");
        const loadKgEl = document.getElementById("loadKg");
        const liftCmEl = document.getElementById("liftCm");
        const pauseSecondsEl = document.getElementById("pauseSeconds");
        const seriesEl = document.getElementById("series");
        const repsEl = document.getElementById("reps");
        const timeLabelEl = document.getElementById("timeLabel");
        const timeEl = document.getElementById("time");
        const statusEl = document.getElementById("status");
        const phaseEl = document.getElementById("phase");
        const powerKwEl = document.getElementById("powerKw");
        const loadKgStatEl = document.getElementById("loadKgStat");
        const liftCmStatEl = document.getElementById("liftCmStat");
        const mobileRepsEl = document.getElementById("mobileReps");
        const mobilePhaseEl = document.getElementById("mobilePhase");
        const mobileTimeLabelEl = document.getElementById("mobileTimeLabel");
        const mobileTimeEl = document.getElementById("mobileTime");
        const mobileStatusEl = document.getElementById("mobileStatus");
        const startBtn = document.getElementById("start");
        const pauseBtn = document.getElementById("pause");
        const resetBtn = document.getElementById("reset");
        const uiToggleBtn = document.getElementById("uiToggle");
        const drawEl = document.getElementById("draw");
        const soundEl = document.getElementById("sound");
        const mirrorEl = document.getElementById("mirror");
        const trackDot = document.getElementById("trackDot");
        const trackText = document.getElementById("trackText");
        const centerHint = document.getElementById("centerHint");
        const centerHintTitle = document.getElementById("centerHintTitle");
        const centerHintBody = document.getElementById("centerHintBody");
        const repFlashEl = document.getElementById("repFlash");
        const pauseBoxEl = document.getElementById("pauseBox");
        const pauseBoxTitleEl = document.getElementById("pauseBoxTitle");
        const pauseBoxTimeEl = document.getElementById("pauseBoxTime");
        const pauseBoxSubEl = document.getElementById("pauseBoxSub");
        const advancedPanelEl = document.getElementById("advancedPanel");
        const advSummaryEl = document.getElementById("advSummary");
        const advPaceEl = document.getElementById("advPace");
        const advActiveEl = document.getElementById("advActive");
        const advAvgIntEl = document.getElementById("advAvgInt");
        const advLastIntEl = document.getElementById("advLastInt");
        const advBestWorstEl = document.getElementById("advBestWorst");
        const advStdEl = document.getElementById("advStd");
        /** @type {HTMLCanvasElement | null} */
        const advChartEl = /** @type {any} */ (document.getElementById("advChart"));
        const advChartCtx = advChartEl ? advChartEl.getContext("2d") : null;

        const clamp = (n, a, b) => Math.max(a, Math.min(b, n));

        function setHint(title, body, show) {
          centerHintTitle.textContent = title;
          centerHintBody.textContent = body;
          centerHint.style.display = show ? "block" : "none";
        }

        function setTracking(ok, msg) {
          trackDot.classList.toggle("ok", !!ok);
          trackDot.classList.toggle("bad", ok === false);
          trackText.textContent = msg;
        }

        function formatTime(ms) {
          const s = Math.max(0, Math.floor(ms / 1000));
          const mm = String(Math.floor(s / 60)).padStart(2, "0");
          const ss = String(s % 60).padStart(2, "0");
          return `${mm}:${ss}`;
        }

        function formatSecondsFromMs(ms) {
          const s = Math.max(0, ms) / 1000;
          if (!Number.isFinite(s)) return "—";
          if (s < 10) return `${s.toFixed(2)} s`;
          if (s < 100) return `${s.toFixed(1)} s`;
          return `${Math.round(s)} s`;
        }

        // ---- Audio (rep sounds, timer beep) ----
        /** @type {AudioContext | null} */
        let audioCtx = null;
        /** @type {GainNode | null} */
        let masterGain = null;
        /** @type {DynamicsCompressorNode | null} */
        let masterLimiter = null;

        function ensureAudio() {
          if (!soundEl?.checked) return null;
          const Ctx = window.AudioContext || window.webkitAudioContext;
          if (!Ctx) return null;
          if (!audioCtx) audioCtx = new Ctx();
          if (audioCtx.state === "suspended") audioCtx.resume().catch(() => {});
          if (!masterGain) {
            masterGain = audioCtx.createGain();
            masterGain.gain.value = 1.0; // full-scale
          }
          if (!masterLimiter) {
            // A limiter-ish compressor so we can push loud without harsh clipping
            masterLimiter = audioCtx.createDynamicsCompressor();
            masterLimiter.threshold.value = -10;
            masterLimiter.knee.value = 0;
            masterLimiter.ratio.value = 20;
            masterLimiter.attack.value = 0.003;
            masterLimiter.release.value = 0.09;
          }
          // Ensure chain is connected (idempotent in practice)
          try {
            masterGain.disconnect();
          } catch (_) {}
          try {
            masterLimiter.disconnect();
          } catch (_) {}
          masterGain.connect(masterLimiter);
          masterLimiter.connect(audioCtx.destination);
          return audioCtx;
        }

        function beep({ freq = 880, ms = 70, gain = 1.0 } = {}) {
          if (!soundEl?.checked) return;
          const ac = ensureAudio();
          if (!ac) return;

          const t0 = ac.currentTime;
          const t1 = t0 + ms / 1000;

          const o = ac.createOscillator();
          const g = ac.createGain();
          o.type = "sine";
          o.frequency.setValueAtTime(freq, t0);

          // soft click-less envelope
          g.gain.setValueAtTime(0.0001, t0);
          g.gain.exponentialRampToValueAtTime(clamp(gain, 0.0001, 1.0), t0 + 0.01);
          g.gain.exponentialRampToValueAtTime(0.0001, t1);

          // Route through master chain (louder + limited)
          o.connect(g).connect(masterGain || ac.destination);
          o.start(t0);
          o.stop(t1 + 0.02);
        }

        function beepStartSoft() {
          // user gesture cue (kept distinct)
          beep({ freq: 523.25, ms: 80, gain: 1.0 });
        }

        function beepHalf() {
          beep({ freq: 659.25, ms: 85, gain: 1.0 });
        }

        function beepTen() {
          beep({ freq: 784, ms: 90, gain: 1.0 });
        }

        function beepCount3() {
          beep({ freq: 988, ms: 55, gain: 1.0 });
        }

        function beepGo() {
          beep({ freq: 1046.5, ms: 110, gain: 1.0 });
        }

        function beepDone() {
          beep({ freq: 880, ms: 120, gain: 1.0 });
        }

        function repFreq(repCount) {
          // Higher rep => higher pitch (bounded)
          return clamp(680 + repCount * 28, 680, 1650);
        }

        function beepRep(repCount) {
          beep({ freq: repFreq(repCount), ms: 55, gain: 1.0 });
        }

        // ---- Session state ----
        let running = false;
        let reps = 0;
        let phase = "—"; // up / down / —
        let lastRepAt = 0;
        let repArmed = false; // waiting for first rep to start/resume timer
        /** @type {number[]} */
        let repTimes = []; // timestamps (performance.now) for current set reps
        let loadKg = 0;
        let liftCm = 0;

        // Handstand push-ups: auto-calibrated head range (helps variants like "squat with hands")
        /** @type {null | number} */
        let hspuHeadMin = null; // smallest (highest) nose.y observed
        /** @type {null | number} */
        let hspuHeadMax = null; // largest (lowest) nose.y observed

        /** @type {null | "prep" | "pause"} */
        let countdownKind = null;
        let countdownEndsAt = 0;
        let countdownTotalMs = 0;
        let countdownHalfBeeped = false;
        let countdownTenBeeped = false;
        /** @type {Set<number>} */
        let countdownLastBeeped = new Set();
        let repFlashTimeout = 0;

        // Timer: countdown if duration > 0, else stopwatch
        let durationMs = 60_000;
        let startedAt = 0;
        let pausedAccum = 0;
        let pauseStartedAt = 0;
        let timerEnded = false; // workout done

        // Series (sets)
        let seriesTotal = 1;
        let seriesIndex = 0; // 0-based
        let seriesActive = false;

        // Mode
        /** @type {"time" | "reps"} */
        let mode = "time";
        let targetReps = 10;

        function getElapsedMs(now) {
          if (!startedAt) return 0;
          if (running) return now - startedAt - pausedAccum;
          if (pauseStartedAt) return pauseStartedAt - startedAt - pausedAccum;
          return now - startedAt - pausedAccum;
        }

        function getDisplayedMs(now) {
          const elapsed = getElapsedMs(now);
          if (durationMs > 0) return Math.max(0, durationMs - elapsed);
          return elapsed;
        }

        function resetSession() {
          running = false;
          reps = 0;
          phase = "—";
          lastRepAt = 0;
          repArmed = false;
          repTimes = [];
          hspuHeadMin = null;
          hspuHeadMax = null;
          seriesTotal = 1;
          seriesIndex = 0;
          seriesActive = false;
          mode = "time";
          targetReps = 10;
          countdownKind = null;
          countdownEndsAt = 0;
          countdownTotalMs = 0;
          countdownHalfBeeped = false;
          countdownTenBeeped = false;
          countdownLastBeeped = new Set();
          if (repFlashTimeout) {
            window.clearTimeout(repFlashTimeout);
            repFlashTimeout = 0;
          }
          repFlashEl?.classList.remove("on");
          if (pauseBoxEl) pauseBoxEl.style.display = "none";
          startedAt = 0;
          pausedAccum = 0;
          pauseStartedAt = 0;
          timerEnded = false;
          repsEl.textContent = "0";
          phaseEl.textContent = "Phase: —";
          statusEl.textContent = "Ready";
          const now = performance.now();
          updatePrimaryDisplay(now);
          updateAdvancedUi(now, true);
        }

        function readMode() {
          const raw = String(modeEl?.value || "time");
          mode = raw === "reps" ? "reps" : "time";
          if (modeEl) modeEl.value = mode;
          return mode;
        }

        function readDuration() {
          const raw = Number(durationEl.value);
          const sec = Number.isFinite(raw) ? clamp(raw, 0, 60 * 60) : 60;
          durationEl.value = String(sec);
          durationMs = sec * 1000;
          const now = performance.now();
          updatePrimaryDisplay(now);
          updateAdvancedUi(now, true);
        }

        function readTargetReps() {
          const raw = Number(targetRepsEl?.value);
          const n = Number.isFinite(raw) ? Math.floor(clamp(raw, 1, 999)) : 10;
          targetReps = n;
          if (targetRepsEl) targetRepsEl.value = String(n);
          const now = performance.now();
          updatePrimaryDisplay(now);
          updateAdvancedUi(now, true);
          return n;
        }

        function readLoadKg() {
          const raw = Number(loadKgEl?.value);
          const n = Number.isFinite(raw) ? clamp(raw, 0, 999) : 0;
          loadKg = Math.round(n * 10) / 10;
          if (loadKgEl) loadKgEl.value = String(loadKg);
          return loadKg;
        }

        function readLiftCm() {
          const raw = Number(liftCmEl?.value);
          const n = Number.isFinite(raw) ? clamp(raw, 0, 300) : 0;
          liftCm = Math.round(n * 10) / 10;
          if (liftCmEl) liftCmEl.value = String(liftCm);
          return liftCm;
        }

        function readPauseSeconds() {
          const raw = Number(pauseSecondsEl?.value);
          const sec = Number.isFinite(raw) ? clamp(raw, 0, 60 * 60) : 10;
          if (pauseSecondsEl) pauseSecondsEl.value = String(sec);
          return sec * 1000;
        }

        function readSeriesCount() {
          const raw = Number(seriesEl?.value);
          const n = Number.isFinite(raw) ? Math.floor(clamp(raw, 1, 99)) : 1;
          if (seriesEl) seriesEl.value = String(n);
          return n;
        }

        function updateModeUi() {
          const m = readMode();
          if (m === "reps") {
            if (timeLabelEl) timeLabelEl.textContent = "Reps left";
            if (durationEl) durationEl.disabled = true;
            if (targetRepsEl) targetRepsEl.disabled = false;
          } else {
            if (timeLabelEl) timeLabelEl.textContent = "Time";
            if (durationEl) durationEl.disabled = false;
            if (targetRepsEl) targetRepsEl.disabled = true;
          }
          const now = performance.now();
          updatePrimaryDisplay(now);
          updateAdvancedUi(now, true);
        }

        function updatePrimaryDisplay(now) {
          if (mode === "reps") {
            const left = Math.max(0, (targetReps || 1) - reps);
            timeEl.textContent = String(left);
            return;
          }
          timeEl.textContent = formatTime(getDisplayedMs(now));
        }

        let lastMobileReadoutAt = 0;
        function updateMobileReadout(now) {
          if (!mobileRepsEl || !mobilePhaseEl || !mobileTimeLabelEl || !mobileTimeEl || !mobileStatusEl) return;
          if (now - lastMobileReadoutAt < 100) return;
          lastMobileReadoutAt = now;
          mobileRepsEl.textContent = String(reps);
          mobilePhaseEl.textContent = `Phase: ${phase === "—" ? "—" : phase}`;
          mobileTimeLabelEl.textContent = String(timeLabelEl?.textContent || "Time");
          mobileTimeEl.textContent = String(timeEl?.textContent || "—");
          mobileStatusEl.textContent = String(statusEl?.textContent || "");
        }

        function withSetPrefix(label) {
          if (!seriesActive || seriesTotal <= 1) return label;
          const setN = clamp(seriesIndex + 1, 1, seriesTotal);
          return `Set ${setN}/${seriesTotal} · ${label}`;
        }

        function flashRepBorder() {
          if (!repFlashEl) return;
          repFlashEl.classList.add("on");
          if (repFlashTimeout) window.clearTimeout(repFlashTimeout);
          repFlashTimeout = window.setTimeout(() => repFlashEl.classList.remove("on"), 160);
        }

        function showPauseBox(title, remainingMs, sub) {
          if (!pauseBoxEl || !pauseBoxTitleEl || !pauseBoxTimeEl || !pauseBoxSubEl) return;
          pauseBoxTitleEl.textContent = title;
          pauseBoxTimeEl.textContent = formatTime(remainingMs);
          pauseBoxSubEl.textContent = sub;
          pauseBoxEl.style.display = "block";
        }

        function hidePauseBox() {
          if (!pauseBoxEl) return;
          pauseBoxEl.style.display = "none";
        }

        function beginCountdown(kind, totalMs) {
          const ms = Math.max(0, Math.floor(totalMs || 0));
          if (ms <= 0) {
            countdownKind = null;
            hidePauseBox();
            return false;
          }
          const now = performance.now();
          countdownKind = kind;
          countdownTotalMs = ms;
          countdownEndsAt = now + ms;
          countdownHalfBeeped = false;
          countdownTenBeeped = false;
          countdownLastBeeped = new Set();
          showPauseBox(kind === "prep" ? "Pause" : "Pause", ms, kind === "prep" ? "Get ready…" : "Rest…");
          return true;
        }

        function endCountdown() {
          countdownKind = null;
          countdownEndsAt = 0;
          countdownTotalMs = 0;
          countdownHalfBeeped = false;
          countdownTenBeeped = false;
          countdownLastBeeped = new Set();
          hidePauseBox();
        }

        function armForFirstRep(label) {
          repArmed = true;
          running = false;
          statusEl.textContent = withSetPrefix(label);
        }

        function startOrResumeTimerOnRep(now) {
          if (timerEnded) return;
          const startingFreshSet = !startedAt;
          if (!startedAt) {
            // first rep starts the timer
            startedAt = now;
            pausedAccum = 0;
            pauseStartedAt = 0;
          } else if (pauseStartedAt) {
            // resume after pause on first rep
            pausedAccum += now - pauseStartedAt;
            pauseStartedAt = 0;
          }
          running = true;
          repArmed = false;
          if (startingFreshSet) beepGo(); // "set start" cue when work interval begins
          statusEl.textContent = withSetPrefix(mode === "time" ? (durationMs > 0 ? "Running (countdown)" : "Running (stopwatch)") : "Running (reps)");
        }

        function finishSet(now) {
          running = false;
          repArmed = false;
          beepDone();

          // next set?
          if (seriesTotal > 1 && seriesIndex + 1 < seriesTotal) {
            seriesIndex += 1;

            // reset per-set counters
            reps = 0;
            repsEl.textContent = "0";
            phase = "—";
            lastRepAt = now;
            repTimes = [];
            hspuHeadMin = null;
            hspuHeadMax = null;
            updateAdvancedUi(now, true);

            // reset per-set timer state (next set starts on first rep)
            startedAt = 0;
            pausedAccum = 0;
            pauseStartedAt = 0;

            const pauseMs = readPauseSeconds();
            if (pauseMs > 0) {
              statusEl.textContent = withSetPrefix("Rest…");
              beginCountdown("pause", pauseMs);
            } else {
              armForFirstRep("Waiting for first rep…");
            }
          } else {
            timerEnded = true;
            statusEl.textContent = "Done";
            updateAdvancedUi(now, true);
          }
        }

        function onRep(now) {
          reps += 1;
          lastRepAt = now;
          repTimes.push(now);
          repsEl.textContent = String(reps);
          flashRepBorder();
          beepRep(reps);
          if (repArmed) startOrResumeTimerOnRep(now);
          updatePrimaryDisplay(now);
          updateAdvancedUi(now, true);

          // Reps mode: end set after N reps
          if (mode === "reps" && targetReps > 0 && reps >= targetReps && !timerEnded && !countdownKind) {
            finishSet(now);
          }
        }

        // ---- Advanced stats + graph ----
        let lastAdvUiAt = 0;

        function mean(values) {
          if (!values || values.length === 0) return null;
          const sum = values.reduce((a, b) => a + b, 0);
          return sum / values.length;
        }

        function stddev(values) {
          if (!values || values.length < 2) return null;
          const m = mean(values);
          if (m == null) return null;
          const v = mean(values.map((x) => (x - m) * (x - m)));
          if (v == null) return null;
          return Math.sqrt(v);
        }

        function resizeAdvChart() {
          if (!advChartEl) return;
          const rect = advChartEl.getBoundingClientRect();
          const dpr = window.devicePixelRatio || 1;
          const w = Math.max(1, Math.floor(rect.width * dpr));
          const h = Math.max(1, Math.floor(rect.height * dpr));
          if (advChartEl.width !== w || advChartEl.height !== h) {
            advChartEl.width = w;
            advChartEl.height = h;
          }
        }

        function drawAdvChart(now) {
          if (!advChartEl || !advChartCtx) return;
          if (!advancedPanelEl?.open) return;

          resizeAdvChart();
          const ctx2 = advChartCtx;
          const w = advChartEl.width;
          const h = advChartEl.height;

          ctx2.clearRect(0, 0, w, h);

          // background
          ctx2.fillStyle = "rgba(0,0,0,0.18)";
          ctx2.fillRect(0, 0, w, h);

          const padL = 34;
          const padR = 10;
          const padT = 10;
          const padB = 22;
          const iw = Math.max(1, w - padL - padR);
          const ih = Math.max(1, h - padT - padB);

          const hasData = repTimes.length > 0;
          const t0 = hasData ? repTimes[0] : now;
          const t1 = hasData ? Math.max(now, repTimes[repTimes.length - 1]) : now;
          const tRange = Math.max(250, t1 - t0);
          const yMax = Math.max(1, mode === "reps" ? Math.max(reps, targetReps || 1) : reps || 1);

          function xOf(t) {
            return padL + ((t - t0) / tRange) * iw;
          }
          function yOf(repN) {
            const v = clamp(repN / yMax, 0, 1);
            return padT + (1 - v) * ih;
          }

          // grid
          ctx2.strokeStyle = "rgba(255,255,255,0.10)";
          ctx2.lineWidth = 1;
          ctx2.beginPath();
          for (let i = 0; i <= 4; i++) {
            const y = padT + (ih * i) / 4;
            ctx2.moveTo(padL, y);
            ctx2.lineTo(padL + iw, y);
          }
          ctx2.stroke();

          // target line (reps mode)
          if (mode === "reps" && targetReps > 0) {
            ctx2.strokeStyle = "rgba(110,231,255,0.30)";
            ctx2.setLineDash([5, 4]);
            ctx2.beginPath();
            ctx2.moveTo(padL, yOf(targetReps));
            ctx2.lineTo(padL + iw, yOf(targetReps));
            ctx2.stroke();
            ctx2.setLineDash([]);
          }

          // cumulative reps line
          ctx2.strokeStyle = "rgba(53,208,127,0.90)";
          ctx2.lineWidth = 2;
          ctx2.beginPath();
          if (!hasData) {
            ctx2.moveTo(padL, yOf(0));
            ctx2.lineTo(padL + iw, yOf(0));
          } else {
            ctx2.moveTo(xOf(t0), yOf(0));
            for (let i = 0; i < repTimes.length; i++) {
              const t = repTimes[i];
              const r = i + 1;
              ctx2.lineTo(xOf(t), yOf(r));
            }
            // extend flat to "now"
            ctx2.lineTo(xOf(t1), yOf(repTimes.length));
          }
          ctx2.stroke();

          // labels
          ctx2.fillStyle = "rgba(255,255,255,0.60)";
          ctx2.font = `${Math.max(10, Math.floor((h / 120) * 11))}px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial`;
          ctx2.textBaseline = "alphabetic";
          ctx2.fillText(String(yMax), 6, yOf(yMax) + 4);
          ctx2.fillText("0", 14, yOf(0) + 4);

          const sec = Math.round(tRange / 1000);
          ctx2.fillText(`${sec}s`, padL + iw - 28, h - 6);
        }

        function updateAdvancedUi(now, force = false) {
          // Update the always-visible stats first (Power / Load).
          (function updatePowerAndLoadUi() {
            if (loadKgStatEl) loadKgStatEl.textContent = String(readLoadKg());
            if (liftCmStatEl) liftCmStatEl.textContent = `Height: ${readLiftCm()} cm`;

            if (!powerKwEl) return;
            if (repTimes.length < 2) {
              powerKwEl.textContent = "—";
              return;
            }
            if (loadKg <= 0 || liftCm <= 0) {
              powerKwEl.textContent = "—";
              return;
            }
            const activeMs = Math.max(0, repTimes[repTimes.length - 1] - repTimes[0]);
            if (activeMs <= 0) {
              powerKwEl.textContent = "—";
              return;
            }
            const g = 9.80665;
            const heightM = liftCm / 100;
            const workJ = loadKg * g * heightM * repTimes.length;
            const pW = workJ / (activeMs / 1000);
            const pKw = pW / 1000;
            powerKwEl.textContent = Number.isFinite(pKw) ? pKw.toFixed(3) : "—";
          })();

          if (!advSummaryEl || !advPaceEl || !advActiveEl || !advAvgIntEl || !advLastIntEl || !advBestWorstEl || !advStdEl)
            return;
          if (!force && now - lastAdvUiAt < 250) return;
          lastAdvUiAt = now;

          if (repTimes.length === 0) {
            advSummaryEl.textContent = "—";
            advPaceEl.textContent = "—";
            advActiveEl.textContent = "—";
            advAvgIntEl.textContent = "—";
            advLastIntEl.textContent = "—";
            advBestWorstEl.textContent = "—";
            advStdEl.textContent = "—";
            drawAdvChart(now);
            return;
          }

          const activeMs = Math.max(0, (repTimes[repTimes.length - 1] || now) - repTimes[0]);
          const paceRpm = activeMs > 0 ? (repTimes.length / activeMs) * 60_000 : null;

          /** @type {number[]} */
          const intervals = [];
          for (let i = 1; i < repTimes.length; i++) intervals.push(repTimes[i] - repTimes[i - 1]);

          const avgInt = mean(intervals);
          const lastInt = intervals.length > 0 ? intervals[intervals.length - 1] : null;
          const bestInt = intervals.length > 0 ? Math.min(...intervals) : null;
          const worstInt = intervals.length > 0 ? Math.max(...intervals) : null;
          const sd = stddev(intervals);

          advPaceEl.textContent = paceRpm != null ? `${paceRpm.toFixed(1)} rpm` : "—";
          advActiveEl.textContent = formatTime(activeMs);
          advAvgIntEl.textContent = avgInt != null ? formatSecondsFromMs(avgInt) : "—";
          advLastIntEl.textContent = lastInt != null ? formatSecondsFromMs(lastInt) : "—";
          advBestWorstEl.textContent =
            bestInt != null && worstInt != null ? `${formatSecondsFromMs(bestInt)} / ${formatSecondsFromMs(worstInt)}` : "—";
          advStdEl.textContent = sd != null ? formatSecondsFromMs(sd) : "—";

          // Summary line (collapsed header)
          const summaryParts = [];
          if (paceRpm != null) summaryParts.push(`${paceRpm.toFixed(0)} rpm`);
          summaryParts.push(`${repTimes.length} reps`);
          advSummaryEl.textContent = summaryParts.join(" · ");

          drawAdvChart(now);
        }

        function start() {
          ensureAudio(); // unlock audio on user gesture
          if (timerEnded) return; // require Reset after done

          // Initialize series on first Start of a workout
          if (!seriesActive && !startedAt && !pauseStartedAt && reps === 0) {
            readMode();
            readTargetReps();
            // series is meaningful for "time countdown" or "reps"; for stopwatch keep it 1
            seriesTotal = mode === "time" && durationMs <= 0 ? 1 : readSeriesCount();
            seriesIndex = 0;
            seriesActive = seriesTotal > 1;
          }

          // If a pause/prep countdown is running, Start acts as "skip"
          if (countdownKind) {
            endCountdown();
            armForFirstRep(startedAt && pauseStartedAt ? "Resume on first rep…" : "Waiting for first rep…");
            return;
          }

          beepStartSoft();

          // If timer is running, do nothing
          if (running) return;

          // If currently paused (manual), arm to resume on first rep
          if (startedAt && pauseStartedAt) {
            armForFirstRep("Resume on first rep…");
            return;
          }

          // Fresh start: optional timed pause, then arm (timer starts on first rep)
          const pauseMs = readPauseSeconds();
          if (pauseMs > 0) {
            // fresh session arm: keep timer unstarted
            repArmed = false;
            running = false;
            pauseStartedAt = 0;
            pausedAccum = 0;
            // don't overwrite startedAt here; it remains 0 until first rep
            statusEl.textContent = "Pause…";
            beginCountdown("prep", pauseMs);
            return;
          }

          armForFirstRep("Waiting for first rep…");
        }

        function pause() {
          ensureAudio();
          if (timerEnded) return;

          // If already in countdown, Pause acts as "skip"
          if (countdownKind) {
            endCountdown();
            armForFirstRep(startedAt && pauseStartedAt ? "Resume on first rep…" : "Waiting for first rep…");
            return;
          }

          // Timed pause: pause timer (if running) then countdown; resume on first rep
          if (running) {
            running = false;
            pauseStartedAt = performance.now();
          }

          const pauseMs = readPauseSeconds();
          if (pauseMs <= 0) {
            statusEl.textContent = "Paused";
            return;
          }

          statusEl.textContent = "Pause…";
          beginCountdown("pause", pauseMs);
        }

        function hardReset() {
          readDuration();
          resetSession();
        }

        // ---- Rep logic helpers ----
        function getPoint(landmarks, idx) {
          const p = landmarks?.[idx];
          if (!p) return null;
          if (!Number.isFinite(p.x) || !Number.isFinite(p.y)) return null;
          return p;
        }

        function angleDeg(a, b, c) {
          // angle ABC (at b)
          const abx = a.x - b.x;
          const aby = a.y - b.y;
          const cbx = c.x - b.x;
          const cby = c.y - b.y;
          const abLen = Math.hypot(abx, aby);
          const cbLen = Math.hypot(cbx, cby);
          if (abLen < 1e-6 || cbLen < 1e-6) return null;
          const dot = abx * cbx + aby * cby;
          const cos = clamp(dot / (abLen * cbLen), -1, 1);
          return (Math.acos(cos) * 180) / Math.PI;
        }

        function avgOrNull(values) {
          const good = values.filter((v) => typeof v === "number" && Number.isFinite(v));
          if (good.length === 0) return null;
          return good.reduce((a, b) => a + b, 0) / good.length;
        }

        function updateSquatCounter(landmarks, now) {
          // indices from MediaPipe Pose
          // left: hip 23, knee 25, ankle 27
          // right: hip 24, knee 26, ankle 28
          const lHip = getPoint(landmarks, 23);
          const lKnee = getPoint(landmarks, 25);
          const lAnk = getPoint(landmarks, 27);
          const rHip = getPoint(landmarks, 24);
          const rKnee = getPoint(landmarks, 26);
          const rAnk = getPoint(landmarks, 28);
          if (!lHip || !lKnee || !lAnk || !rHip || !rKnee || !rAnk) return;

          const l = angleDeg(lHip, lKnee, lAnk);
          const r = angleDeg(rHip, rKnee, rAnk);
          const knee = avgOrNull([l, r]);
          if (knee == null) return;

          // Thresholds (tuneable):
          // up: >160°, down: <95°
          const upTh = 160;
          const downTh = 95;

          if (phase === "—") {
            phase = knee > upTh ? "up" : knee < downTh ? "down" : "up";
          } else if (phase === "up") {
            if (knee < downTh) phase = "down";
          } else if (phase === "down") {
            if (knee > upTh) {
              // Count at full extension (coming back up)
              if (now - lastRepAt > 350) {
                onRep(now);
              }
              phase = "up";
            }
          }
        }

        function updatePushupCounter(landmarks, now) {
          // left: shoulder 11, elbow 13, wrist 15
          // right: shoulder 12, elbow 14, wrist 16
          const ls = getPoint(landmarks, 11);
          const le = getPoint(landmarks, 13);
          const lw = getPoint(landmarks, 15);
          const rs = getPoint(landmarks, 12);
          const re = getPoint(landmarks, 14);
          const rw = getPoint(landmarks, 16);
          if (!ls || !le || !lw || !rs || !re || !rw) return;

          const la = angleDeg(ls, le, lw);
          const ra = angleDeg(rs, re, rw);
          const elbow = avgOrNull([la, ra]);
          if (elbow == null) return;

          // Thresholds:
          // up: >165°, down: <95°
          const upTh = 165;
          const downTh = 95;

          if (phase === "—") {
            phase = elbow > upTh ? "up" : elbow < downTh ? "down" : "up";
          } else if (phase === "up") {
            if (elbow < downTh) phase = "down";
          } else if (phase === "down") {
            if (elbow > upTh) {
              if (now - lastRepAt > 350) {
                onRep(now);
              }
              phase = "up";
            }
          }
        }

        function updateHandstandPushupCounter(landmarks, now) {
          // Handstand push-ups (and similar "squat with hands" variants):
          // - Primary: elbow flexion/extension (looser thresholds than standard push-ups)
          // - Fallback: head (nose) vertical movement auto-calibrated per set

          // elbow points (if visible)
          const ls = getPoint(landmarks, 11);
          const le = getPoint(landmarks, 13);
          const lw = getPoint(landmarks, 15);
          const rs = getPoint(landmarks, 12);
          const re = getPoint(landmarks, 14);
          const rw = getPoint(landmarks, 16);

          // head point (often more reliable for these variants)
          const nose = getPoint(landmarks, 0);

          /** @type {null | number} */
          let elbow = null;
          if (ls && le && lw && rs && re && rw) {
            const la = angleDeg(ls, le, lw);
            const ra = angleDeg(rs, re, rw);
            elbow = avgOrNull([la, ra]);
          }

          /** @type {null | number} */
          const headY = nose ? nose.y : null; // 0 top, 1 bottom
          if (typeof headY === "number" && Number.isFinite(headY)) {
            if (hspuHeadMin == null || headY < hspuHeadMin) hspuHeadMin = headY;
            if (hspuHeadMax == null || headY > hspuHeadMax) hspuHeadMax = headY;
          }

          // Elbow thresholds (more forgiving than push-ups; tuned for partial ROM)
          const elbowUpTh = 155; // near extension
          const elbowDownTh = 130; // bent
          const elbowUp = elbow != null && elbow > elbowUpTh;
          const elbowDown = elbow != null && elbow < elbowDownTh;

          // Head thresholds (dynamic): detect "down" when head is low in frame (larger y)
          let headUp = false;
          let headDown = false;
          if (
            headY != null &&
            hspuHeadMin != null &&
            hspuHeadMax != null &&
            Number.isFinite(hspuHeadMin) &&
            Number.isFinite(hspuHeadMax)
          ) {
            const range = hspuHeadMax - hspuHeadMin;
            // Need some real movement before trusting this signal (avoid noise-triggered reps)
            if (range > 0.04) {
              const upTh = hspuHeadMin + range * 0.35;
              const downTh = hspuHeadMin + range * 0.75;
              headUp = headY < upTh;
              headDown = headY > downTh;
            }
          }

          const isDown = elbowDown || headDown;
          const isUp = elbowUp || headUp;

          if (phase === "—") {
            phase = isDown ? "down" : "up";
          } else if (phase === "up") {
            if (isDown) phase = "down";
          } else if (phase === "down") {
            if (isUp) {
              if (now - lastRepAt > 500) {
                onRep(now);
              }
              phase = "up";
            }
          }
        }

        function updatePullupCounter(landmarks, now) {
          // Use elbow flexion/extension similar to push-ups, but count when reaching the "top" (flexed elbows)
          // left: shoulder 11, elbow 13, wrist 15
          // right: shoulder 12, elbow 14, wrist 16
          const ls = getPoint(landmarks, 11);
          const le = getPoint(landmarks, 13);
          const lw = getPoint(landmarks, 15);
          const rs = getPoint(landmarks, 12);
          const re = getPoint(landmarks, 14);
          const rw = getPoint(landmarks, 16);
          if (!ls || !le || !lw || !rs || !re || !rw) return;

          const la = angleDeg(ls, le, lw);
          const ra = angleDeg(rs, re, rw);
          const elbow = avgOrNull([la, ra]);
          if (elbow == null) return;

          // Thresholds (tuneable):
          // bottom (arms extended): >160°
          // top (pulled up): <85°
          const bottomTh = 160;
          const topTh = 85;

          if (phase === "—") {
            phase = elbow > bottomTh ? "down" : elbow < topTh ? "up" : "down";
          } else if (phase === "down") {
            // transition to top => count rep
            if (elbow < topTh) {
              if (now - lastRepAt > 450) {
                onRep(now);
              }
              phase = "up";
            }
          } else if (phase === "up") {
            // must return to bottom before next rep
            if (elbow > bottomTh) phase = "down";
          }
        }

        function updatePhaseUi() {
          phaseEl.textContent = `Phase: ${phase === "—" ? "—" : phase}`;
        }

        // ---- Canvas sizing & drawing ----
        function resizeCanvasToViewport() {
          const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
          const w = Math.floor(window.innerWidth * dpr);
          const h = Math.floor(window.innerHeight * dpr);
          if (canvasEl.width !== w || canvasEl.height !== h) {
            canvasEl.width = w;
            canvasEl.height = h;
          }
        }

        function drawFrame(image, results) {
          resizeCanvasToViewport();
          const w = canvasEl.width;
          const h = canvasEl.height;

          // draw camera frame to cover canvas
          ctx.save();
          ctx.clearRect(0, 0, w, h);

          const mirror = !!mirrorEl.checked;
          if (mirror) {
            ctx.translate(w, 0);
            ctx.scale(-1, 1);
          }

          // image is video frame with natural size; draw it cover-style
          const srcW = image.videoWidth || image.width;
          const srcH = image.videoHeight || image.height;
          let drawW = w;
          let drawH = h;
          let dx = 0;
          let dy = 0;
          if (srcW && srcH) {
            const scale = Math.max(w / srcW, h / srcH);
            drawW = srcW * scale;
            drawH = srcH * scale;
            dx = (w - drawW) / 2;
            dy = (h - drawH) / 2;
            ctx.drawImage(image, dx, dy, drawW, drawH);
          } else {
            // fallback
            ctx.fillStyle = "#000";
            ctx.fillRect(0, 0, w, h);
          }

          if (drawEl.checked && results.poseLandmarks) {
            // MediaPipe landmarks are normalized to the *source frame*.
            // Since we draw the camera using "cover" (cropping), we remap landmarks to match.
            const adjusted = results.poseLandmarks.map((lm) => ({
              ...lm,
              x: (dx + lm.x * drawW) / w,
              y: (dy + lm.y * drawH) / h,
            }));
            drawConnectors(ctx, adjusted, POSE_CONNECTIONS, { color: "rgba(110,231,255,0.9)", lineWidth: 3 });
            drawLandmarks(ctx, adjusted, { color: "rgba(53,208,127,0.9)", lineWidth: 2, radius: 3 });
          }

          ctx.restore();
        }

        // ---- Main loop UI ----
        function tickUi() {
          const now = performance.now();
          const shown = getDisplayedMs(now);
          updatePrimaryDisplay(now);
          updateAdvancedUi(now, false);

          // Timed pause / prep countdown UX
          if (countdownKind) {
            const kind = countdownKind;
            const remaining = countdownEndsAt - now;
            const remainingClamped = Math.max(0, remaining);

            const halfAt = countdownEndsAt - countdownTotalMs / 2;
            if (!countdownHalfBeeped && now >= halfAt) {
              countdownHalfBeeped = true;
              beepHalf();
            }
            if (!countdownTenBeeped && remaining <= 10_000 && remaining > 0) {
              countdownTenBeeped = true;
              beepTen();
            }
            const secLeft = Math.ceil(remaining / 1000);
            if (remaining > 0 && secLeft <= 3 && secLeft >= 1 && !countdownLastBeeped.has(secLeft)) {
              countdownLastBeeped.add(secLeft);
              beepCount3();
            }

            showPauseBox("Pause", remainingClamped, kind === "prep" ? "Get ready…" : "Rest…");

            if (remaining <= 0) {
              endCountdown();
              armForFirstRep(kind === "pause" && startedAt && pauseStartedAt ? "Resume on first rep…" : "Waiting for first rep…");
            }
          }

          // Time mode: end set when countdown hits 0
          if (mode === "time" && running && durationMs > 0 && shown <= 0 && !timerEnded) {
            finishSet(now);
          }

          updatePhaseUi();
          updateMobileReadout(now);
          requestAnimationFrame(tickUi);
        }

        // ---- MediaPipe Pose setup ----
        async function main() {
          setHint("Starting…", "Initializing MediaPipe and requesting webcam permission.", true);
          updateModeUi();
          readDuration();
          readTargetReps();
          readLoadKg();
          readLiftCm();
          resetSession();

          // If not in secure context, webcam will likely fail (except localhost in some browsers).
          if (!window.isSecureContext) {
            setHint(
              "Secure context required",
              "Open this page via https:// or http://localhost using a local server (file:// usually blocks camera).",
              true
            );
          }

          const pose = new Pose({
            locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}`,
          });
          pose.setOptions({
            modelComplexity: 1,
            smoothLandmarks: true,
            enableSegmentation: false,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5,
          });

          pose.onResults((results) => {
            const now = performance.now();

            const hasPose = !!results.poseLandmarks && results.poseLandmarks.length > 0;
            if (hasPose) {
              setTracking(true, "Tracking");
              setHint("", "", false);
            } else {
              setTracking(false, "No pose");
              // keep hint subtle (only when running)
              if (running) {
                setHint("No pose detected", "Step back so the camera can see you.", true);
              }
            }

            drawFrame(results.image, results);

            // Rep counting: run while active OR armed (waiting for first rep),
            // but never during the pause/prep countdown.
            if (timerEnded) return;
            if (countdownKind) return;
            if (!running && !repArmed) return;
            if (!hasPose) return;

            if (exerciseEl.value === "squats") updateSquatCounter(results.poseLandmarks, now);
            if (exerciseEl.value === "pushups") updatePushupCounter(results.poseLandmarks, now);
            if (exerciseEl.value === "handstandpushups")
              updateHandstandPushupCounter(results.poseLandmarks, now);
            if (exerciseEl.value === "pullups") updatePullupCounter(results.poseLandmarks, now);
          });

          // Camera helper uses getUserMedia; attach to the hidden video
          const camera = new Camera(videoEl, {
            onFrame: async () => {
              await pose.send({ image: videoEl });
            },
            width: 1280,
            height: 720,
          });

          try {
            await camera.start();
            setHint("", "", false);
            setTracking(null, "Waiting…");
          } catch (err) {
            console.error(err);
            setTracking(false, "Camera blocked");
            setHint(
              "Camera permission needed",
              "Please allow webcam access in your browser permissions and reload the page.",
              true
            );
          }

          // UI hooks
          startBtn.addEventListener("click", () => start());
          pauseBtn.addEventListener("click", () => pause());
          resetBtn.addEventListener("click", () => hardReset());
          function setUiExpanded(next) {
            document.body.classList.toggle("uiExpanded", !!next);
            uiToggleBtn?.setAttribute("aria-expanded", next ? "true" : "false");
            if (uiToggleBtn) uiToggleBtn.textContent = next ? "Close" : "Settings";
            // Avoid weird layout when re-opening on mobile
            if (!next && advancedPanelEl && "open" in advancedPanelEl) advancedPanelEl.open = false;
          }

          uiToggleBtn?.addEventListener("click", () => {
            const next = !document.body.classList.contains("uiExpanded");
            setUiExpanded(next);
          });

          durationEl.addEventListener("change", () => {
            const wasRunning = running;
            readDuration();
            // preserve running state; just update display
            if (!startedAt) updatePrimaryDisplay(performance.now());
            statusEl.textContent = wasRunning ? statusEl.textContent : "Ready";
          });

          pauseSecondsEl?.addEventListener("change", () => {
            // normalize value
            readPauseSeconds();
          });

          seriesEl?.addEventListener("change", () => {
            // normalize value
            readSeriesCount();
          });

          modeEl?.addEventListener("change", () => {
            updateModeUi();
          });

          targetRepsEl?.addEventListener("change", () => {
            readTargetReps();
          });

          loadKgEl?.addEventListener("change", () => {
            readLoadKg();
            updateAdvancedUi(performance.now(), true);
          });

          liftCmEl?.addEventListener("change", () => {
            readLiftCm();
            updateAdvancedUi(performance.now(), true);
          });

          exerciseEl.addEventListener("change", () => {
            // switch exercise: keep timer, reset reps/phase
            reps = 0;
            phase = "—";
            lastRepAt = 0;
            repTimes = [];
            hspuHeadMin = null;
            hspuHeadMax = null;
            repsEl.textContent = "0";
            phaseEl.textContent = "Phase: —";
            updateAdvancedUi(performance.now(), true);
          });

          mirrorEl.addEventListener("change", () => {
            // keep video mirrored for consistency (canvas does the mirroring)
            videoEl.style.transform = mirrorEl.checked ? "scaleX(-1)" : "none";
          });
          videoEl.style.transform = mirrorEl.checked ? "scaleX(-1)" : "none";

          window.addEventListener("resize", resizeCanvasToViewport);
          resizeCanvasToViewport();
          window.addEventListener("resize", () => updateAdvancedUi(performance.now(), true));
          advancedPanelEl?.addEventListener("toggle", () => {
            // Allow layout to settle before measuring canvas
            window.setTimeout(() => updateAdvancedUi(performance.now(), true), 0);
          });
          requestAnimationFrame(tickUi);
        }

        main();
      })();
    </script>
  </body>
</html>

